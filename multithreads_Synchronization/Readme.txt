Implementation and Design
The design of the program is simple. As the single thread merge sort is a recursive method and has a level of log2n, thus I use multi-threads to deal with the comparison in every level. The number of threads in each level is the half of the number of subarrays in this level. A “for” lop is used in the main function to create the threads for each of the level. The sub-function “Merge” is associated to every thread to deal with comparison between two subarrays. 
1.	A global int barrier is used to note the state of the thread. The initial value of the barrier is the number of the threads in this level. In child threads, a mutex lock is set before the change of this global variable to make sure no race condition happens. Whenever a thread has finish its task, it will first wait on the mutex lock and minus the value of barrier after its entry. When this value is bigger than zero, the thread will wait on the condition variable by using pthread_cond_wait.  And when this value is smaller than zero, it means that all threads in this level has finish their tasks. Using the pthread_cond_broadcast to release all the threads. 
2.	In every thread, I print message 1 before the thread waits on condition variable and print message 2 after the broadcast. If the pattern is that all the message 2 are after all the message 1, it means the barrier is working properly.
3.	My main thread does not participates in the comparisons. It simply waits for all the child threads in this level to finish and continue to create the threads for the next level. A mutex lock is set before the judgement statement of barrier, to make sure no race condition happens here. The parent thread also waits on the condition variable. 
4.	In the sub-function Merge, I use a temp array to store the merge-sorted subarray. And I free this temp array after it copy the value to the original array which is set as a global variable. 

